package com.twitter.hogan

import java.util.concurrent.atomic.AtomicInteger
import java.util.regex.Pattern

import groovy.text.Template
import groovy.transform.Canonical

import org.codehaus.groovy.ast.ClassHelper

enum State {
	IN_TEXT,
	IN_TAG_TYPE,
	IN_TAG
}

@Canonical
class HoganToken {
	CharSequence n
	def tag
	def i
	def indent
	String text
	String otag
	String ctag
	def nodes
	def end
}

/** Helper object */
class Hogan {
	static compile(String text, Map options = [:]) {
		def scanner = new HoganScanner()
		def parser = new HoganParser()
		def compiler = new GroovyHoganCompiler()

		def tokens = scanner.scan(text)
		def tree = parser.parse(tokens)

		if (options.asString) {
			compiler.generate(tree)
		} else {
			compiler.compile(tree)
		}
	}
}

class ParseException extends RuntimeException {
	def token
	ParseException(String message, token = null) {
		super(message)
		this.token = token
	}
}

class HoganTemplate implements Template {

	Writable make() {
		make(null)
	}

	Writable make(Map binding) {
		''
	}

}

/**
 * The base script used for content generated by a compiled
 * template. Provides methods to access the context and is
 * equivalent to Hogan.Template in Hogan.js (name changed
 * to match Groovy templating convention)
 */
class HoganPage extends Script {

	static AMP_PATTERN = ~/&/
	static LT_PATTERN = ~/</
	static GT_PATTERN = ~/>/
	static APOS_PATTERN = ~/\'/
	static QUOT_PATTERN = ~/\"/
	static HCHARS_PATTERN = ~/[&<>\"\']/

	 private static final Set<Class<?>> WRAPPER_TYPES = getWrapperTypes();

	String source
	HoganCompiler compiler
	Map options

	private StringBuilder buffer = new StringBuilder()

	HoganPage() {

	}

	HoganPage(String source, HoganCompiler compiler, Map options = [:]) {
		this.source = source
		this.compiler = compiler
		this.options = options
	}

	Object run() {
		render(getBinding()?.variables)
	}

	// overridden by compiled, maybe abstract
	String r(Deque context, Map partials, String indent) {
		''
	}

	String t(def val) {
		val == null ? '' : val as String
	}

	def render(Map context = [:], Map partials = [:], String indent = null) {
		buffer = new StringBuilder()
		def contextStack = new ArrayDeque()
		contextStack.push(context)
		ri(contextStack, partials, indent)
	}

	def ri(Deque context, Map partials, String indent) {
		r(context, partials, indent)
	}

	def rp(String name, Deque context, Map partials, String indent) {
		def partial = partials[name]

		if (!partial) return ''

		if (compiler && partial instanceof String) {
			partial = compiler.compile(partial, options)
		}

		return partial.ri(context, partials, indent)
	}

	def rs(Deque context, Map partials, Closure section) {
		def tail = context.peek()

		if (!isArray(tail)) {
			// do we need to clone here?
			section.call()
			return
		}

		tail.each {
			context.push(it)
			section.call()
			context.pop()
		}
	}

	def s(def val, Deque ctx, Map partials, boolean inverted, int start, int end, String tags) {
		def pass

		if (val instanceof Closure) {
			val = ls(val, ctx, partials, inverted, start, end , tags)
		}

		pass = (val == '') || val // default groovy truthy with empty string counting as 'true'

		if (!inverted && pass && ctx) {
			ctx.push(isPrimitive(val) ? ctx.peek() : val)
		}

		return pass
	}

	def d(String key, Deque ctx, Map partials, boolean returnFound) {
		def names = key.tokenize('.')
		def val = f(names[0], ctx, partials, returnFound)
		def cx = null

		if (key == '.' && isArray(ctx.toArray()[1])) {
			return ctx.peek()
		}

		for (int i = 1; i < names.size(); i++) {
			if (val && !isPrimitive(val) && hasProperty(val, names[i])) {
				cx = val
				val = val[names[i]]
			} else {
				val = ''
			}
		}

		if (returnFound && !val) {
			return false
		}

		if (!returnFound && val instanceof Closure) {
			ctx.push(cx)
			val = this.lv(val, ctx, partials)
			ctx.pop()
		}

		return val
	}

	def f(String key, Deque ctx, Map partials, boolean returnFound) {
		def level = ctx.find { m -> hasProperty(m, key) }

		if (level == null) {
			return (returnFound) ? false : ''
		}

		def val = level[key]

		if (!returnFound && val instanceof Closure) {
			val = this.lv(val, ctx, partials)
		}

		val
	}

	def ho(Closure val, def cx, Map partials, String text, String tags) {
		def opts = [:] + options
		opts.delimiters = tags

		def c = val.clone()
		c.delegate = cx

		def t = c.call(text, { t ->
			compiler.compile(t, opts).render(cx, partials)
		})
		b(compiler.compile(t.toString(), opts).render(cx, partials))

		false
	}

	def ls(Closure val, Deque ctx, Map partials, boolean inverted, int start, int end, String tags) {
		def cx = ctx.peek()

		// because Groovy Closures have the default 'it' argument, higher order
		// templates must have 2 arguments
		if (!inverted && compiler && val.maximumNumberOfParameters > 1) {
			this.ho(val, cx, partials, source[start..<end], tags)
		}

		def c = val.clone()
		c.delegate = cx
		def t = c.call()

		if (t instanceof Closure) {
			if (inverted) {
				return true
			} else if (compiler) {
				return this.ho(t, cx, partials, source[start..<end], tags)
			}
		}

		return t
	}

	def lv(Closure val, Deque ctx, Map partials) {
		def cx = ctx.peek()
		def result = val.call(cx)

		if (result instanceof Closure) {
			result = result.call(cx)
		}

		result = t(result)

		if (compiler && ~result.indexOf("{\u007B")) {
			return compiler.compile(result, options).render(cx, partials)
		}

		return result
	}

	void b(s) {
		buffer << (s ?: '')
	}

	String fl() {
		def output = buffer.toString()
		buffer = new StringBuilder()
		output
	}

	String v(def str) {
		str = t(str)
		return HCHARS_PATTERN.matcher(str) ?
			str
				.replaceAll(AMP_PATTERN, '&amp;')
				.replaceAll(LT_PATTERN, '&lt;')
				.replaceAll(GT_PATTERN, '&gt;')
				.replaceAll(APOS_PATTERN, '&#39;')
				.replaceAll(QUOT_PATTERN, '&quot;') :
			str
	}

	boolean hasProperty(obj, prop) {
		if (obj instanceof Map) {
			obj.containsKey(prop)
		} else {
			obj.getProperties().containsKey(prop)
		}
	}

	boolean isArray(obj) {
		obj instanceof Iterable || obj.getClass().isArray()
	}

	boolean isPrimitive(obj) {
		WRAPPER_TYPES.contains(obj.class)
	}

	private static Set<Class<?>> getWrapperTypes()
	{
		Set<Class<?>> ret = new HashSet<Class<?>>();
		ret.add(Boolean.class);
		ret.add(Character.class);
		ret.add(Byte.class);
		ret.add(Short.class);
		ret.add(Integer.class);
		ret.add(Long.class);
		ret.add(Float.class);
		ret.add(Double.class);
		ret.add(Void.class);
		return ret;
	}
}

abstract class HoganCompiler {

	static QUOT_PATTERN = ~/\"/
	static NEWLINE_PATTERN = ~/\n/
	static CR_PATTERN = ~/\r/

	abstract void writeCode(tree, name)
	abstract void section(nodes, id, method, start, end, tags)
	abstract void invertedSection(nodes, id, method)
	abstract void partial(tok)
	abstract void tripleStache(id, method)
	abstract void variable(id, method)
	abstract void text(id)

	private StringBuilder buffer = new StringBuilder()

	String generate(List tree, String name) {
		buffer = new StringBuilder()
		writeCode(tree, name)
		return buffer.toString()
	}

	protected walk(tree) {
		tree.eachWithIndex { token, i ->
			def tag = (token instanceof String) ? null : token.tag
			if (tag == '#') {
				section(token.nodes, token.n, chooseMethod(token.n), token.i, token.end, token.otag + ' ' + token.ctag)
			} else if (tag == '^') {
				invertedSection(token.nodes, token.n, chooseMethod(token.n))
			} else if (tag == '>' || tag == '<') {
				partial(token)
			} else if (tag == '{' || tag == '&') {
				tripleStache(token.n, chooseMethod(token.n))
			} else if (tag == '\n') {
				text('"\\n"')
				text(tree.size() - 1 == i ? '' : 'i')
			} else if (tag == '_v') {
				variable(token.n, chooseMethod(token.n))
			} else if (token instanceof String) {
				text('"' + esc(token) + '"')
			}
		}
	}

	protected void print(String str = '') {
		buffer << str
	}

	protected void println(String str = '') {
		buffer << str + '\n'
	}

	protected esc(String s) {
		s.replaceAll('\\\\', "\\\\\\\\")
			.replaceAll(QUOT_PATTERN, '\\\\"')
			.replaceAll(NEWLINE_PATTERN, "\\\\n")
			.replaceAll(CR_PATTERN, "\\\\r")
	}

	protected String chooseMethod(String name) {
		name.indexOf('.') < 0 ? 'f' : 'd'
	}
}

class GroovyHoganCompiler extends HoganCompiler {

	ClassLoader classLoader

	static AtomicInteger counter = new AtomicInteger()

	static importLines = [
		'com.twitter.hogan.HoganCompiler',
		'com.twitter.hogan.HoganPage'
	]

	public GroovyHoganCompiler() {
		classLoader = new GroovyClassLoader(Thread.currentThread().getContextClassLoader());
	}

	HoganPage compile(String source, Map options = [:]) {
		def scanner = new HoganScanner()
		def parser = new HoganParser()

		def tokens = scanner.scan(source)
		def tree = parser.parse(tokens)
		compile(tree, options)
	}

	HoganPage compile(List tree, Map options = [:]) {
		def name = options.name ?: "hogan${System.nanoTime()}_${counter.incrementAndGet()} "
		def source = generate(tree, name)
		def clazz = classLoader.parseClass(source)
		def args = new Object[3]
		args[0] = source
		args[1] = this
		args[2] = options
		return (HoganPage)clazz.newInstance(args)
	}

	void writeImports() {
		importLines.each {
			println("import ${it}")
		}
		println()
	}

	void writeCode(tree, name) {
		writeImports()

		print('class ')
		print(name)
		println(' extends HoganPage {')
		println("public ${name}() { super(null, null); }")
		println("public ${name}(String s, HoganCompiler c, Map o = [:]) { super(s, c, o); }")
		println('String r(Deque c, Map p, String i) {')
		println('def _ = this')
		println('_.b(i ?: "")')
		walk(tree)
		println()
		println('return _.fl()')
		println('}')
		println('}')
	}

	void section(nodes, id, method, start, end, tags) {
		def escId = esc(id)
		println("if(_.s(_.${method}('${escId}',c,p,true),c,p,false,${start},${end},'${tags}')) {")
		println('_.rs(c,p) { ')
		walk(nodes)
		println('}')
		println('c.pop()')
		println('}')
	}

	void invertedSection(nodes, id, method) {
		def escId = esc(id)
		println("if(!_.s(_.${method}('${escId}',c,p,true),c,p,true,0,0,'')) {")
		walk(nodes)
		println('}')
	}

	void partial(tok) {
		def escN = esc(tok.n)
		println("_.b(_.rp('${escN}',c,p,'${tok.indent ?: ''}'));")
	}

	void tripleStache(id, method) {
		def escId = esc(id)
		println("_.b(_.t(_.${method}('${escId}',c,p,false)))")
	}

	void variable(id, method) {
		def escId = esc(id)
		println("_.b(_.v(_.${method}('${escId}',c,p,false)))")
	}

	void text(str) {
		println("_.b(${str})")
	}
}

class HoganParser {
	List parse(List tokens, String text = null, Map options = [:]) {
		buildTree(new ArrayDeque(tokens), '', new ArrayDeque(), options.sectionTags ?: [])
	}

	List buildTree(Queue tokens, String kind, Queue stack, Collection customTags) {
		def instructions = []
		def token = null

		while (!tokens.empty) {
			token = tokens.pop()

			if (!(token instanceof String) && (token.tag == '#' || token.tag == '^' || isOpener(token, customTags))) {
				stack.push(token)
				token.nodes = buildTree(tokens, token.tag, stack, customTags)
				instructions.add(token)

			} else if (!(token instanceof String) && token.tag == '/') {
				if (stack.empty) {
					throw new ParseException('Closing tag without opener: ' + token.n, token)
				}

				def opener = stack.pop()

				if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
					throw new ParseException('Nesting error: ' + opener.n + ' vs. ' + token.n, token)
				}

				opener.end = token.i
				return instructions
			} else {
				instructions.add(token)
			}
		}

		if (!stack.empty) {
			def top = stack.pop()
			throw new ParseException('Missing closing tag: ' + top.n, top)
		}

		return instructions
	}

	private boolean isOpener(HoganToken token, List tags) {
		def custom = tags.find { it.o == token.n }

		if (custom) {
			token.tag = '#'
			return true
		}

		return false
	}

	private boolean isCloser(String close, String open, List tags) {
		tags.any { it.c == close && it.o == open }
	}
}

class HoganScanner {

	static tagTypes = [
		'#': 1,
		'^': 2,
		'/': 3,
		'!': 4,
		'>': 5,
		'<': 6,
		'=': 7,
		'_v': 8,
		'{': 9,
		'&': 10
	]

	List tokens = []
	StringBuilder buf = new StringBuilder()
	int lineStart = 0
	String otag = '{{'
	String ctag = '}}'
	def seenTag = false

	def scan(String text, List delimiters = null) {
		def tagType

		State state = State.IN_TEXT
		int len = text.length()
		int i = 0

		tokens = []
		buf = new StringBuilder()
		lineStart = 0

		// TODO: handle passed in delimiters

		for (i = 0; i < len; i++) {
			if (state == State.IN_TEXT) {
				if (tagChange(otag, text, i)) {
					--i;
					addBuf();
					state = State.IN_TAG_TYPE
				} else {
					if (text[i] == '\n') {
						filterLine(seenTag)
					} else {
						buf << text[i]
					}
				}
			} else if (state == State.IN_TAG_TYPE) {
				i += otag.length() - 1
				boolean tag = tagTypes.containsKey(text[i+1])
				tagType = tag ? text[i+1] : '_v'
				if (tagType == '=') {
					i  = changeDelimiters(text, i)
					state = State.IN_TEXT
				} else {
					if (tag) {
						i++
					}
					state = State.IN_TAG
				}
				seenTag = i
			} else {
				if (tagChange(ctag, text, i)) {
					tokens.add(new HoganToken(
						tag: tagType,
						n: buf.toString().trim(),
						otag: otag,
						ctag: ctag,
						i: (tagType == '/') ? seenTag - otag.length() : i + ctag.length()
					))
					buf = new StringBuilder()
					i += ctag.length() - 1
					state = State.IN_TEXT

					if (tagType == '{') {
						if (ctag == '}}') {
							i++
						} else {
							cleanTripleStache(tokens[-1])
						}
					}
				} else {
					buf << text[i]
				}
			}
		}

		filterLine(seenTag, true)
		tokens
	}

	private filterLine(def haveSeenTag, boolean noNewLine = false) {
		addBuf()

		if (haveSeenTag && lineIsWhitespace()) {
			for (int j = lineStart; j < tokens.size(); j++) {
				if (tokens[j] instanceof String && j < (tokens.size() - 1)) {
					def next = tokens[j+1]

					if (next.tag == '>') {
						next.indent = tokens[j]
					}

					tokens.remove(j)
				}
			}
		} else if (!noNewLine) {
			tokens.push(new HoganToken(tag: '\n'))
		}

		seenTag = false
		lineStart = tokens.size()
	}

	private int changeDelimiters(String text, int index) {
		def close = '=' + ctag
		def closeIndex = text.indexOf(close, index)
		def delimiters = text.substring(text.indexOf('=', index) + 1, closeIndex)
			.trim()
			.split(' ')

		otag = delimiters[0]
		ctag = delimiters[1]

		return closeIndex + close.length() - 1
	}

	private boolean tagChange(String tag, String text, int index) {
		if (text[index] != tag[0])
			return false

		for (int j = 0; j < tag.length(); j++) {
			if (text[index + j] != tag[j])
				return false
		}

		return true
	}

	private boolean lineIsWhitespace() {
		tokens[lineStart..<tokens.size()].every { t ->
			(t instanceof String) ?
				t.trim().length() == 0 :
				tagTypes[t.tag] < tagTypes['_v']
		}
	}

	private addBuf() {
		if (buf.length()) {
			tokens.add(buf.toString())
			buf = new StringBuilder()
		}
	}

}