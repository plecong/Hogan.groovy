package com.pinkhippo.hogan

/**
 * The base script used for content generated by a compiled
 * template. Provides methods to access the context and is
 * equivalent to Hogan.Template in Hogan.js (name changed
 * to match Groovy templating convention)
 */
abstract class HoganPage extends Script {

	static AMP_PATTERN = ~/&/
	static LT_PATTERN = ~/</
	static GT_PATTERN = ~/>/
	static APOS_PATTERN = ~/\'/
	static QUOT_PATTERN = ~/\"/
	static HCHARS_PATTERN = ~/[&<>\"\']/

	String source
	String generated
	List tokens
	HoganCompiler compiler
	Map options

	private StringBuilder buffer = new StringBuilder()

	HoganPage(String source, HoganCompiler compiler, Map options = [:]) {
		this.source = source
		this.compiler = compiler
		this.options = options
	}

	Object run() {
		render(getBinding()?.variables)
	}

	// overridden by compiled, maybe abstract
	abstract String r(Deque context, Map partials, String indent)

	String t(def val) {
		val == null ? '' : val as String
	}

	def render(Map context = [:], Map partials = [:], String indent = null) {
		buffer = new StringBuilder()
		def contextStack = new ArrayDeque()
		contextStack.push(context)
		ri(contextStack, partials, indent)
	}

	def ri(Deque context, Map partials, String indent) {
		r(context, partials, indent)
	}

	def rp(String name, Deque context, Map partials, String indent) {
		def partial = partials[name]

		if (!partial) return ''

		if (compiler && partial instanceof String) {
			partial = compiler.compile(partial.toString(), options)
		}

		return partial.ri(context, partials, indent)
	}

	def rs(Deque context, Map partials, Closure section) {
		def tail = context.peek()

		if (!ObjectUtils.isArray(tail)) {
			// do we need to clone here?
			section.call()
			return
		}

		tail.each {
			context.push(it)
			section.call()
			context.pop()
		}
	}

	def s(def val, Deque ctx, Map partials, boolean inverted, int start, int end, String tags) {
		def pass

		if (ObjectUtils.isArray(val) && val.size() == 0) {
			return false
		}

		if (val instanceof Closure) {
			val = ls(val, ctx, partials, inverted, start, end , tags)
		}

		pass = (val == '') || val as Boolean // default groovy truthy with empty string counting as 'true'

		if (!inverted && pass && ctx) {
			ctx.push(ObjectUtils.isPrimitive(val) ? ctx.peek() : val)
		}

		return pass
	}

	def d(String key, Deque ctx, Map partials, boolean returnFound) {
		def names = key.tokenize('.')
		def val = f(names[0], ctx, partials, returnFound)
		def cx = null

		if (key == '.' && ObjectUtils.isArray(ctx.toArray()[1])) {
			return ctx.peek()
		}

		for (int i = 1; i < names.size(); i++) {
			if (val && !ObjectUtils.isPrimitive(val) && ObjectUtils.hasProperty(val, names[i])) {
				cx = val
				val = val[names[i]]
			} else {
				val = ''
			}
		}

		if (returnFound && !val) {
			return false
		}

		if (!returnFound && val instanceof Closure) {
			ctx.push(cx)
			val = this.lv(val, ctx, partials)
			ctx.pop()
		}

		return val
	}

	def f(String key, Deque ctx, Map partials, boolean returnFound) {
		def level = ctx.find { m -> ObjectUtils.hasProperty(m, key) }

		if (level == null) {
			return (returnFound) ? false : ''
		}

		def val = level[key]

		if (!returnFound && val instanceof Closure) {
			val = this.lv(val, ctx, partials)
		}

		val
	}

	def ho(Closure val, def cx, Map partials, String text, String tags) {
		def opts = [:] + options
		opts.delimiters = tags

		def c = val.clone()
		c.delegate = cx

		def t = c.call(text, { t ->
			compiler.compile(t, opts).render(cx, partials)
		})
		b(compiler.compile(t.toString(), opts).render(cx, partials))

		false
	}

	def ls(Closure val, Deque ctx, Map partials, boolean inverted, int start, int end, String tags) {
		def cx = ctx.peek()

		// because Groovy Closures have the default 'it' argument, higher order
		// templates must have 2 arguments
		if (!inverted && compiler && val.maximumNumberOfParameters > 1) {
			return this.ho(val, cx, partials, source[start..<end], tags)
		}

		def c = val.clone()
		c.delegate = cx
		def t = c.call() // should the text be passed in here? thinking no

		if (t instanceof Closure) {
			if (inverted) {
				return true
			} else if (compiler) {
				return this.ho(t, cx, partials, source[start..<end], tags)
			}
		}

		return t
	}

	def lv(Closure val, Deque ctx, Map partials) {
		def cx = ctx.peek()
		def result = val.call(cx)

		if (result instanceof Closure) {
			result = result.call(cx)
		}

		result = t(result)

		if (compiler && ~result.indexOf("{\u007B")) {
			return compiler.compile(result, options).render(cx, partials)
		}

		return result
	}

	void b(s) {
		buffer << (s ?: '')
	}

	String fl() {
		def output = buffer.toString()
		buffer = new StringBuilder()
		output
	}

	String v(def str) {
		str = t(str)
		return HCHARS_PATTERN.matcher(str) ?
			str
				.replaceAll(AMP_PATTERN, '&amp;')
				.replaceAll(LT_PATTERN, '&lt;')
				.replaceAll(GT_PATTERN, '&gt;')
				.replaceAll(APOS_PATTERN, '&#39;')
				.replaceAll(QUOT_PATTERN, '&quot;') :
			str
	}

}
